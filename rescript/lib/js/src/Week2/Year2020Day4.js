// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Util = require("../Util.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_HashMapString = require("rescript/lib/js/belt_HashMapString.js");

function splitToPassportRaw(input) {
  return input.split("\n\n");
}

function normalizeSpaces(input) {
  return input.trim().replace(/\s+/g, " ");
}

function parseFieldPair(input) {
  var pair = input.split(":");
  if (pair.length !== 2) {
    return {
            TAG: /* Error */1,
            _0: "failed to parse field: " + input + ""
          };
  }
  var key = pair[0];
  var value = pair[1];
  return {
          TAG: /* Ok */0,
          _0: [
            key,
            value
          ]
        };
}

function parsePassportData(input) {
  return Belt_Result.map(Util.Result.traverse(Belt_Array.map(normalizeSpaces(input).split(" "), parseFieldPair)), Belt_HashMapString.fromArray);
}

function parsePassport1(map) {
  var results_0 = Belt_HashMapString.get(map, "byr");
  var results_1 = Belt_HashMapString.get(map, "iyr");
  var results_2 = Belt_HashMapString.get(map, "eyr");
  var results_3 = Belt_HashMapString.get(map, "hgt");
  var results_4 = Belt_HashMapString.get(map, "hcl");
  var results_5 = Belt_HashMapString.get(map, "ecl");
  var results_6 = Belt_HashMapString.get(map, "pid");
  var results_7 = Belt_HashMapString.get(map, "cid");
  var byr = results_0;
  if (byr === undefined) {
    return {
            TAG: /* Error */1,
            _0: "fields are not fullfiled"
          };
  }
  var iyr = results_1;
  if (iyr === undefined) {
    return {
            TAG: /* Error */1,
            _0: "fields are not fullfiled"
          };
  }
  var eyr = results_2;
  if (eyr === undefined) {
    return {
            TAG: /* Error */1,
            _0: "fields are not fullfiled"
          };
  }
  var hgt = results_3;
  if (hgt === undefined) {
    return {
            TAG: /* Error */1,
            _0: "fields are not fullfiled"
          };
  }
  var hcl = results_4;
  if (hcl === undefined) {
    return {
            TAG: /* Error */1,
            _0: "fields are not fullfiled"
          };
  }
  var ecl = results_5;
  if (ecl === undefined) {
    return {
            TAG: /* Error */1,
            _0: "fields are not fullfiled"
          };
  }
  var pid = results_6;
  if (pid !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: {
              byr: byr,
              iyr: iyr,
              eyr: eyr,
              hgt: hgt,
              hcl: hcl,
              ecl: ecl,
              pid: pid,
              cid: results_7
            }
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: "fields are not fullfiled"
          };
  }
}

function part1(input) {
  return Belt_Array.keepMap(Belt_Array.map(Belt_Array.map(input.split("\n\n"), parsePassportData), (function (__x) {
                    return Belt_Result.flatMap(__x, parsePassport1);
                  })), Util.Result.toOption).length;
}

function getRegMatched(input, re) {
  return Belt_Option.flatMap(Belt_Option.flatMap(Belt_Option.map(Caml_option.null_to_opt(re.exec(input)), (function (prim) {
                        return prim;
                      })), (function (__x) {
                    return Belt_Array.get(__x, 0);
                  })), (function (prim) {
                if (prim == null) {
                  return ;
                } else {
                  return Caml_option.some(prim);
                }
              }));
}

function parseYear(input) {
  return Util.Result.fromOption(Belt_Option.flatMap(getRegMatched(input, /^\d{4}$/), Belt_Int.fromString), {
              TAG: /* Error */1,
              _0: "invalid format (year): " + input + ""
            });
}

function parseBirthYear(input) {
  return Belt_Result.flatMap(parseYear(input), (function (year) {
                if (Util.$$Range.inRange(year, 1920, 2002)) {
                  return {
                          TAG: /* Ok */0,
                          _0: year
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "invalid byr: " + input + ""
                        };
                }
              }));
}

function parseIssueYear(input) {
  return Belt_Result.flatMap(parseYear(input), (function (year) {
                if (Util.$$Range.inRange(year, 2010, 2020)) {
                  return {
                          TAG: /* Ok */0,
                          _0: year
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "invalid iyr: " + input + ""
                        };
                }
              }));
}

function parseExpYear(input) {
  return Belt_Result.flatMap(parseYear(input), (function (year) {
                if (Util.$$Range.inRange(year, 2020, 2030)) {
                  return {
                          TAG: /* Ok */0,
                          _0: year
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "invalid eyr: " + input + ""
                        };
                }
              }));
}

function parseLen(input) {
  return Util.Result.fromOption(Belt_Option.flatMap(Belt_Option.map(Caml_option.null_to_opt(/^(\d+)(cm|in)/.exec(input)), (function (prim) {
                        return prim;
                      })), (function (matches) {
                    if (matches.length !== 3) {
                      return ;
                    }
                    var num = matches[1];
                    var unit = matches[2];
                    return Belt_Option.flatMap(Belt_Option.flatMap((num == null) ? undefined : Caml_option.some(num), Belt_Int.fromString), (function (n) {
                                  if (!(unit == null)) {
                                    if (unit === "cm") {
                                      return {
                                              TAG: /* Cm */0,
                                              _0: n
                                            };
                                    } else if (unit === "in") {
                                      return {
                                              TAG: /* Inch */1,
                                              _0: n
                                            };
                                    } else {
                                      return ;
                                    }
                                  }
                                  
                                }));
                  })), {
              TAG: /* Error */1,
              _0: "invalid format (len): " + input + ""
            });
}

function parseHeight(input) {
  return Belt_Result.flatMap(parseLen(input), (function (len) {
                if (len.TAG === /* Cm */0) {
                  var val = len._0;
                  if (Util.$$Range.inRange(val, 150, 193)) {
                    return {
                            TAG: /* Ok */0,
                            _0: {
                              TAG: /* Cm */0,
                              _0: val
                            }
                          };
                  } else {
                    return {
                            TAG: /* Error */1,
                            _0: "out of range height(cm): " + String(val) + ""
                          };
                  }
                }
                var val$1 = len._0;
                if (Util.$$Range.inRange(val$1, 59, 76)) {
                  return {
                          TAG: /* Ok */0,
                          _0: {
                            TAG: /* Inch */1,
                            _0: val$1
                          }
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "out of range height(in): " + String(val$1) + ""
                        };
                }
              }));
}

function parseHairColor(input) {
  return Util.Result.fromOption(getRegMatched(input, /^#[0-9a-f]{6}$/), {
              TAG: /* Error */1,
              _0: "invalid hcl: " + input + ""
            });
}

function parseEyeColor(input) {
  switch (input) {
    case "amb" :
        return {
                TAG: /* Ok */0,
                _0: /* Amb */0
              };
    case "blu" :
        return {
                TAG: /* Ok */0,
                _0: /* Blu */1
              };
    case "brn" :
        return {
                TAG: /* Ok */0,
                _0: /* Brn */2
              };
    case "grn" :
        return {
                TAG: /* Ok */0,
                _0: /* Grn */4
              };
    case "gry" :
        return {
                TAG: /* Ok */0,
                _0: /* Gry */3
              };
    case "hzl" :
        return {
                TAG: /* Ok */0,
                _0: /* Hzl */5
              };
    case "oth" :
        return {
                TAG: /* Ok */0,
                _0: /* Oth */6
              };
    default:
      return {
              TAG: /* Error */1,
              _0: "invalid ecl: " + input + ""
            };
  }
}

function parsePassportID(input) {
  return Util.Result.fromOption(getRegMatched(input, /^\d{9}$/), {
              TAG: /* Error */1,
              _0: "invalid pid: " + input + ""
            });
}

function getValueWithParser(map, key, parser) {
  return Belt_Result.flatMap(Util.Result.fromOption(Belt_HashMapString.get(map, key), {
                  TAG: /* Error */1,
                  _0: "" + key + " required"
                }), parser);
}

function parsePassport2(map) {
  var progress_0 = getValueWithParser(map, "byr", parseBirthYear);
  var progress_1 = getValueWithParser(map, "iyr", parseIssueYear);
  var progress_2 = getValueWithParser(map, "eyr", parseExpYear);
  var progress_3 = getValueWithParser(map, "hgt", parseHeight);
  var progress_4 = getValueWithParser(map, "hcl", parseHairColor);
  var progress_5 = getValueWithParser(map, "ecl", parseEyeColor);
  var progress_6 = getValueWithParser(map, "pid", parsePassportID);
  var progress_7 = Belt_HashMapString.get(map, "cid");
  var byr = progress_0;
  if (byr.TAG === /* Ok */0) {
    var iyr = progress_1;
    if (iyr.TAG === /* Ok */0) {
      var eyr = progress_2;
      if (eyr.TAG === /* Ok */0) {
        var hgt = progress_3;
        if (hgt.TAG === /* Ok */0) {
          var hcl = progress_4;
          if (hcl.TAG === /* Ok */0) {
            var ecl = progress_5;
            if (ecl.TAG === /* Ok */0) {
              var pid = progress_6;
              if (pid.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: {
                          byr: byr._0,
                          iyr: iyr._0,
                          eyr: eyr._0,
                          hgt: hgt._0,
                          hcl: hcl._0,
                          ecl: ecl._0,
                          pid: pid._0,
                          cid: progress_7
                        }
                      };
              }
              
            }
            
          }
          
        }
        
      }
      
    }
    
  }
  return {
          TAG: /* Error */1,
          _0: Belt_Option.getWithDefault(Belt_Option.map(Util.$$Option.traverse([
                        Util.Result.toOption(Util.Result.swap(byr)),
                        Util.Result.toOption(Util.Result.swap(progress_1)),
                        Util.Result.toOption(Util.Result.swap(progress_2)),
                        Util.Result.toOption(Util.Result.swap(progress_3)),
                        Util.Result.toOption(Util.Result.swap(progress_4)),
                        Util.Result.toOption(Util.Result.swap(progress_5)),
                        Util.Result.toOption(Util.Result.swap(progress_6))
                      ]), (function (__x) {
                      return __x.join(", ");
                    })), "fields are not fullfiled")
        };
}

function part2(input) {
  return Belt_Array.keepMap(Belt_Array.map(Belt_Array.map(input.split("\n\n"), parsePassportData), (function (__x) {
                    return Belt_Result.flatMap(__x, parsePassport2);
                  })), Util.Result.toOption).length;
}

function main(param) {
  var input = Fs.readFileSync("input/Week2/Year2020Day4.input.txt", "utf8");
  var __x = part1(input);
  console.log("part1:", __x);
  var __x$1 = part2(input);
  console.log("part2:", __x$1);
}

main(undefined);

exports.splitToPassportRaw = splitToPassportRaw;
exports.normalizeSpaces = normalizeSpaces;
exports.parseFieldPair = parseFieldPair;
exports.parsePassportData = parsePassportData;
exports.parsePassport1 = parsePassport1;
exports.part1 = part1;
exports.getRegMatched = getRegMatched;
exports.parseYear = parseYear;
exports.parseBirthYear = parseBirthYear;
exports.parseIssueYear = parseIssueYear;
exports.parseExpYear = parseExpYear;
exports.parseLen = parseLen;
exports.parseHeight = parseHeight;
exports.parseHairColor = parseHairColor;
exports.parseEyeColor = parseEyeColor;
exports.parsePassportID = parsePassportID;
exports.getValueWithParser = getValueWithParser;
exports.parsePassport2 = parsePassport2;
exports.part2 = part2;
exports.main = main;
/*  Not a pure module */
