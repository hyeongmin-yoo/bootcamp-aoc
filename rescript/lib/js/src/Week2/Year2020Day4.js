// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Util = require("../Util.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_HashMapString = require("rescript/lib/js/belt_HashMapString.js");

function splitToPassportRaw(input) {
  return input.split("\n\n");
}

function normalizeSpaces(input) {
  return input.trim().replace(/\s+/g, " ");
}

function parseFieldPair(input) {
  var pair = input.split(":");
  if (pair.length !== 2) {
    return {
            TAG: /* Error */1,
            _0: "failed to parse field: " + input + ""
          };
  }
  var key = pair[0];
  var value = pair[1];
  return {
          TAG: /* Ok */0,
          _0: [
            key,
            value
          ]
        };
}

function parsePassportData(input) {
  return Belt_Result.map(Util.Result.traverse(Belt_Array.map(input.split(" "), parseFieldPair)), Belt_HashMapString.fromArray);
}

function parseYear(input) {
  return Util.Result.fromOption(Belt_Option.flatMap(Util.$$String.getExactlyMatched(input, /^\d{4}$/), Belt_Int.fromString), {
              TAG: /* Error */1,
              _0: "invalid format (year): " + input + ""
            });
}

function parseBirthYear(input) {
  return Belt_Result.flatMap(parseYear(input), (function (year) {
                if (Util.$$Range.inRange(year, 1920, 2002)) {
                  return {
                          TAG: /* Ok */0,
                          _0: year
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "invalid byr: " + input + ""
                        };
                }
              }));
}

function parseIssueYear(input) {
  return Belt_Result.flatMap(parseYear(input), (function (year) {
                if (Util.$$Range.inRange(year, 2010, 2020)) {
                  return {
                          TAG: /* Ok */0,
                          _0: year
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "invalid iyr: " + input + ""
                        };
                }
              }));
}

function parseExpYear(input) {
  return Belt_Result.flatMap(parseYear(input), (function (year) {
                if (Util.$$Range.inRange(year, 2020, 2030)) {
                  return {
                          TAG: /* Ok */0,
                          _0: year
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "invalid eyr: " + input + ""
                        };
                }
              }));
}

function parseLen(input) {
  return Util.Result.fromOption(Belt_Option.flatMap(Belt_Option.map(Caml_option.null_to_opt(/^(\d+)(cm|in)/.exec(input)), (function (prim) {
                        return prim;
                      })), (function (matches) {
                    if (matches.length !== 3) {
                      return ;
                    }
                    var num = matches[1];
                    var unit = matches[2];
                    return Belt_Option.flatMap(Belt_Option.flatMap((num == null) ? undefined : Caml_option.some(num), Belt_Int.fromString), (function (n) {
                                  if (!(unit == null)) {
                                    if (unit === "cm") {
                                      return {
                                              TAG: /* Cm */0,
                                              _0: n
                                            };
                                    } else if (unit === "in") {
                                      return {
                                              TAG: /* Inch */1,
                                              _0: n
                                            };
                                    } else {
                                      return ;
                                    }
                                  }
                                  
                                }));
                  })), {
              TAG: /* Error */1,
              _0: "invalid format (len): " + input + ""
            });
}

function parseHeight(input) {
  return Belt_Result.flatMap(parseLen(input), (function (len) {
                if (len.TAG === /* Cm */0) {
                  var val = len._0;
                  if (Util.$$Range.inRange(val, 150, 193)) {
                    return {
                            TAG: /* Ok */0,
                            _0: {
                              TAG: /* Cm */0,
                              _0: val
                            }
                          };
                  } else {
                    return {
                            TAG: /* Error */1,
                            _0: "out of range height(cm): " + String(val) + ""
                          };
                  }
                }
                var val$1 = len._0;
                if (Util.$$Range.inRange(val$1, 59, 76)) {
                  return {
                          TAG: /* Ok */0,
                          _0: {
                            TAG: /* Inch */1,
                            _0: val$1
                          }
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "out of range height(in): " + String(val$1) + ""
                        };
                }
              }));
}

function parseHairColor(input) {
  return Util.Result.fromOption(Util.$$String.getExactlyMatched(input, /^#[0-9a-f]{6}$/), {
              TAG: /* Error */1,
              _0: "invalid hcl: " + input + ""
            });
}

function parseEyeColor(input) {
  switch (input) {
    case "amb" :
    case "blu" :
    case "brn" :
    case "grn" :
    case "gry" :
    case "hzl" :
    case "oth" :
        return {
                TAG: /* Ok */0,
                _0: input
              };
    default:
      return {
              TAG: /* Error */1,
              _0: "invalid ecl: " + input + ""
            };
  }
}

function parsePassportID(input) {
  return Util.Result.fromOption(Util.$$String.getExactlyMatched(input, /^\d{9}$/), {
              TAG: /* Error */1,
              _0: "invalid pid: " + input + ""
            });
}

function getRequired(map, key) {
  return Util.Result.fromOption(Belt_HashMapString.get(map, key), {
              TAG: /* Error */1,
              _0: "" + key + " required"
            });
}

function parsePassport2(map) {
  var prog_byr = Belt_Result.flatMap(getRequired(map, "byr"), parseBirthYear);
  var prog_iyr = Belt_Result.flatMap(getRequired(map, "iyr"), parseIssueYear);
  var prog_eyr = Belt_Result.flatMap(getRequired(map, "eyr"), parseExpYear);
  var prog_hgt = Belt_Result.flatMap(getRequired(map, "hgt"), parseHeight);
  var prog_hcl = Belt_Result.flatMap(getRequired(map, "hcl"), parseHairColor);
  var prog_ecl = Belt_Result.flatMap(getRequired(map, "ecl"), parseEyeColor);
  var prog_pid = Belt_Result.flatMap(getRequired(map, "pid"), parsePassportID);
  var prog_cid = Belt_HashMapString.get(map, "cid");
  var byr = prog_byr;
  if (byr.TAG === /* Ok */0) {
    var iyr = prog_iyr;
    if (iyr.TAG === /* Ok */0) {
      var eyr = prog_eyr;
      if (eyr.TAG === /* Ok */0) {
        var hgt = prog_hgt;
        if (hgt.TAG === /* Ok */0) {
          var hcl = prog_hcl;
          if (hcl.TAG === /* Ok */0) {
            var ecl = prog_ecl;
            if (ecl.TAG === /* Ok */0) {
              var pid = prog_pid;
              if (pid.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: {
                          byr: byr._0,
                          iyr: iyr._0,
                          eyr: eyr._0,
                          hgt: hgt._0,
                          hcl: hcl._0,
                          ecl: ecl._0,
                          pid: pid._0,
                          cid: prog_cid
                        }
                      };
              }
              
            }
            
          }
          
        }
        
      }
      
    }
    
  }
  return {
          TAG: /* Error */1,
          _0: Util.$$String.withDefault(Util.$$Option.concatSomes([
                      Util.Result.toErrSome(prog_byr),
                      Util.Result.toErrSome(prog_iyr),
                      Util.Result.toErrSome(prog_eyr),
                      Util.Result.toErrSome(prog_hgt),
                      Util.Result.toErrSome(prog_hcl),
                      Util.Result.toErrSome(prog_ecl),
                      Util.Result.toErrSome(prog_pid)
                    ]).join(", "), "fields are not fullfiled")
        };
}

function part1(input) {
  return Belt_Array.keepMap(Belt_Array.map(Belt_Array.map(Belt_Array.map(input.split("\n\n"), normalizeSpaces), parsePassportData), (function (__x) {
                    return Belt_Result.flatMap(__x, parsePassport2);
                  })), Util.Result.toOption).length;
}

function main(param) {
  var input = Fs.readFileSync("input/Week2/Year2020Day4.input.txt", "utf8");
  var __x = part1(input);
  console.log("part2:", __x);
}

main(undefined);

exports.splitToPassportRaw = splitToPassportRaw;
exports.normalizeSpaces = normalizeSpaces;
exports.parseFieldPair = parseFieldPair;
exports.parsePassportData = parsePassportData;
exports.parseYear = parseYear;
exports.parseBirthYear = parseBirthYear;
exports.parseIssueYear = parseIssueYear;
exports.parseExpYear = parseExpYear;
exports.parseLen = parseLen;
exports.parseHeight = parseHeight;
exports.parseHairColor = parseHairColor;
exports.parseEyeColor = parseEyeColor;
exports.parsePassportID = parsePassportID;
exports.getRequired = getRequired;
exports.parsePassport2 = parsePassport2;
exports.part1 = part1;
exports.main = main;
/*  Not a pure module */
